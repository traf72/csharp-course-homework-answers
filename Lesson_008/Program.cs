/*******************************************************************************************
    1. Данные имена выдают ошибки компиляции. Определите почему и предложите исправления.
*******************************************************************************************/

// Идентификатор не может содержать символ '$'
string name = "Alice";


// Идентификатор не может начинаться с цифры
string titleOf1C = "1C System";
// или
string oneCTitle = "1C System";


// Идентификатор не может содержать символ '-'
int pagesСount = 598;


// Идентификатор не может совпадать с ключевыми словами C#
string @namespace = "Database";
// или
string nameSpace = "Database";


/*********************************************************************************************************************
    2. Данные имена валидны, но не соответствуют конвенции. Поправьте имена переменных в соответствии с конвенцией.
*********************************************************************************************************************/

// Имена переменных должны начинаться с маленькой буквы
string description = "Social media site";

// Имена переменных не должны содержать знак '_', а каждое новое слово внутри идентификатора должно начинаться с большой буквы
decimal totalPrice = 1000000;

// Каждое новое слово внутри идентификатора должн начинаться с большой буквы
bool isBusy = false;

// Имена переменных не должны начинаться со знака '_'
char symbol = 'A';


/**********************************************************************************************************
    3. Хорошие ли имена у объявленных ниже переменных? Если нет, то предложите более подходящие имена.
**********************************************************************************************************/

// Из имени переменной должно быть понятно, что она в себе содержит

// Предназначена для хранения максимальной высоты здания.
int maxHeight = 68;
// или
int buildingMaxHeight = 68;


// Предназначена для хранения баланса по счёту клиента.
decimal accountBalance = 523468;
// или
decimal clientAccountBalance = 523468;


// Предназначена для хранения средней температуры в комнате.
double averageTemperature = 22.5;
// или
double flatAverageTemperature = 22.5;


// Предназначена для хранения флага, авторизован ли пользователь в системе.
bool isAuthorized = true;
// или
bool isUserAuthorized = true;


// Предназначена для хранения здоровья игрока.
byte playerHealth = 78;  // Лучше всегда использовать именования на английском


/************************************
    4. Исправьте ошибки типизации.
************************************/

// Тип byte беззнаковый, то есть, он не может содержать отрицательные числа. Здесь нам нужно использовать подходящий знаковый тип,
// например, short, если значения амплитуды попадают в его дипазон. Если вдруг нам нужен более широкий диапазон, то мы можем
// расширить тип до int или long.
short amplitude = -50;

// Максимально возможное значение типа short - это 32767, а количество лайков у нас более 68 тысяч.
// Даже тип ushort нам тут не подойдёт. Наиболее подходящие типы тут либо int, либо uint.
int numberOfLikes = 68423;

// Максимально возможное значение типа uint - это немногим больше 4 млрд., а мировое население составляет более 8 млрд.
// Наиболее подходщие типы тут либо long, либо ulong.
long worldPopulation = 8100000000;

// Тип char предназначен для хранения единичного символа, а "Bob" - это строка, состоящая из трёх символов.
// Необходимо сменить тип char на тип string и заключить строку "Bob" в двойные кавычки.
string userName = "Bob";

// Мы пытаемся присвоить типу bool строковое значение (помним, что строки оборачиваются в двойные кавычки).
// Булевы значения true и false не нужно оборачивать в кавычки.
bool isCompleted = true;

// Тут нет ошибки компиляции, но всё же тип выбран неверно. Из имени переменной мы понимаем, что она хранит баланс на счету в банке,
// а значит деньги. Помним, что если нам нужно хранить деньги, то мы должны использовать только тип decimal.
decimal bankAccountBalance = 7543279;


/*****************************************
    5. Упростите объявления переменных.
*****************************************/

int pageNum = 341;                          // Int32 можно упростить до int
string articleName = "Animals of Africa";   // String можно упростить до string
bool isAlive = false;                       // Boolean можно упростить до bool, а new bool() - это то же самое, что и false
ushort flightAltitude = 5534;               // UInt16 можно упростить до ushort
float distance = 0;                         // Single можно упростить до float, а new Single() - это то же самое, что и 0


/***************************************
    6. Исправьте ошибки компиляции.
***************************************/

// Нельзя объявлять переменную с помощью ключевого слова var, не присвоив ей значение сразу при объявлении.
// 1. Объявить переменную, явно указав тип.
{
    string emailAddress;
    emailAddress = "test@mail.ru";
}

// 2. Присвоить значение сразу при объявлении
{
    var emailAddress = "test@mail.ru";
}

// Нельзя обращаться к переменной до присвоения ей какого-либо значение.
// 1. Поместить строку с присвоением значения перед выводом в консоль.
{
    int minutesCount;
    minutesCount = 10;
    Console.WriteLine(minutesCount);
}

// 2. Присвоить переменной значение сразу при объявлении.
{
    int minutesCount = 10;
    Console.WriteLine(minutesCount);
}


// Максимальное значение типа byte - это 255, а мы пытаемся переприсвоить значение на 720. Нужно выбрать другой тип данных, например, short
short plainSpeed = 180;
plainSpeed = 720;

// Мы объявили переменную типа char, чтобы хранить в ней цифру, а на следующей строке пытаемся поместить в неё уже двузначное число.
// Если мы хотим хранить только цифры, то тип выбран верно, но мы не должны пытаться сохранять туда числа.
// Если же мы хотим хранить числа любой длины, то нам необходимо сменить тип char на тип string, и лучше также переименовать переменную, например, в number.
string number = "9";
number = "10";

// Мы пытаемся переприсвоить константу. Если мы все-таки хотим иметь возможность изменять данное значение в будущем,
// то мы должны убрать ключевое слово const из объявления переменной.
int viewsCount = 2342;
viewsCount = 4289;

// Константы должны быть известны на этапе компиляции, то есть, мы можем присвоить константе только литерал. Мы не можем присвоить
// переменной вызов метода и при этом пометить её константой. Таковы требования языка C#.
int character = Console.Read();


/***********************************************************************
    7. Какой фактический тип имеют неявно типизированные переменные?
***********************************************************************/

var isHealthy = true;                           // bool
var message = "Hello!";                         // string
var ruble = '₽';                                // char
var weight = 50.6;                              // double
var distanceToAndromeda = 24600000000000000;    // long
var key = Console.ReadKey();                    // ConsoleKeyInfo


/***********************************************************************************************************************
    8. Вам нужно хранить температуру по Цельсию в пределах от абсолютного нуля до примерно 8000 градусов.
       При этом вам нужно хранить только целочисленные значения температуры.
         8.1. Какой тип данных вы могли бы выбрать для данной задачи? Предложите несколько вариантов.
         8.2. Если бы вам нужно было хранить температуру от 0 до 200 градусов, расширился ли бы список подходящих типов?
              А если бы вы были ограничены только CLS-совместимыми типами?
***********************************************************************************************************************/

/*
    8.1. Из условия мы видим, что диапазон хранения примерно от -273 (абсолютный ноль) до 8000 градусов. То есть, во-первых, нам нужно иметь
         возможность хранить отрицательные числа, а во-вторых мы должны выбрать подходящий диапазон. Также в условии сказано, что нам достатоно
         хранить только целочисленные значения. Из таблицы мы видим, что наиболее подходящий для нас тип - это short. Он полностью охватывает наш
         диапазон и при этом занимает наименьшее количество памяти. Также мы могли бы использовать типы int или long, но при они были бы избыточны
         с точки зрения памяти.
*/

/*
    8.2. В данном случае нам уже не нужно хранить отрицательные значения, а значит нам также подойдут все unsigned (беззнаковые) типы.
         Также, так как диапазон сузился, то мы могли бы использовать тип byte, потому что его диапазон 0..255 покрывает наши потребоности.
         То есть, список подходящих типов расширился бы до: byte, short, int, long, ushort, uint, ulong. При этом самым оптимальным
         с точки зрения памяти был бы тип byte.
         Если бы мы были ограничены CLS-совместимостью, то мы бы не смогли использовать типы ushort, uint и ulong.
         То есть, список типов сузился бы до: byte, short, int, long. При этом самым оптимальным с точки зрения памяти так и остался бы тип byte.
*/
