using System.Globalization;

// Сохранение исходной культуры в переменную, чтобы была возможность вернуть её обратно.
// Будет необходимо в некоторых заданиях.
CultureInfo originalCulture = CultureInfo.CurrentCulture;


/******************************************************************
    1. Определите, равны ли два идентификатора ниже.
         1.1. С учётом регистра.
         1.2. Без учёта регистра.

       Приведите несколько вариантов, если они возможны.
******************************************************************/

string id1 = "aB3x9Yz12Q";
string id2 = "ab3x9yz12q";

// Так как это просто строковые идентификаторы, то нам тут необязательно и даже нежелательно учитывать культуру.
// Оптимальнее всего тут использовать "Ordinal" сравнение.

Console.WriteLine("-----------------Ordinal case-sensitive comparison-----------------");

// 1.1. С учётом регистра.

// Вариант 1: просто использовать оператор "==", так как он как раз выполняет "Ordinal" сравнение с учётом регистра.
Console.WriteLine(id1 == id2);

// Вариант 2: использовать метод "Equals" с явным указанием типа сравнения.
Console.WriteLine(id1.Equals(id2, StringComparison.Ordinal));           // Экземплярный метод
Console.WriteLine(string.Equals(id1, id2, StringComparison.Ordinal));   // Статический метод

// Вариант 3 (не рекомендуется): использовать метод "Equals" без явного указания типа сравнения (по умолчанию используется "Ordinal").
Console.WriteLine(id1.Equals(id2));           // Экземплярный метод
Console.WriteLine(string.Equals(id1, id2));   // Статический метод


Console.WriteLine("\n-----------------Ordinal case-insensitive comparison-----------------");

// 1.2. Без учёта регистра.

// Вариант 1 (рекомендуется): использовать метод "Equals" с явным указанием типа сравнения.
Console.WriteLine(id1.Equals(id2, StringComparison.OrdinalIgnoreCase));           // Экземплярный метод
Console.WriteLine(string.Equals(id1, id2, StringComparison.OrdinalIgnoreCase));   // Статический метод

// Вариант 2: привести обе строки к одинаковому регистру и использовать оператор "==".
/*
    Заметьте, что используется именно "ToUpperInvariant", а не просто "ToUpper". Результат в обоих случаях будет верный,
    но "ToUpperInvariant" будет работать чуть быстрее, так как использует инвариантную, а не текущую культуру.
    Если мы просто хотим нормализовать регистр для сравнения, то этого более чем достаточно, и данный вариант предпочтительный.
    Если же, например, пользователь вводит строку, а мы хотим отобразить ему её в верхнем регистре, то тут уже нужен вариант,
    который будет учитывать текущую культуру пользователя, то есть, "ToUpper".
    Ссылка на документацию: https://learn.microsoft.com/en-us/dotnet/standard/base-types/best-practices-strings#stringtoupper-and-stringtolower
*/
Console.WriteLine(id1.ToUpperInvariant() == id2.ToUpperInvariant());


Console.WriteLine("\n-----------------Comparison of strings with different encodings-----------------");

/*******************************************************************************************************************************
    2. Вы отлаживаете неприятный баг. Вы сравниваете две строки. Одна приходит к вам из базы данных, а другая от пользователя.
       В отладчике вы чётко видите, что строки одинаковые, но при сравнении получаете "False". В чём может быть причина?
       Какие есть варианты исправления?
*******************************************************************************************************************************/

/*
    Всё дело в том, что для сравнения применяется оператор "==", который использует "Ordinal" сравнение.
    Символ "ê" в кодировке Unicode может кодироваться по-разному, поэтому "Ordinal" сравнение не гарантирует
    корректный результат. Чтобы избежать таких проблем, лучше использовать вариант сравнения "CurrentCulture".
    Вариант "InvariantCulture" в данном случае также бы сработал, так как он тоже знает об особенностях кодирования
    данного символа. Но тут мы обрабатываем ввод пользователя. Так как слово французское, то, скорей всего,
    и пользователь использует французскую культуру. А она как нельзя лучше умеет учитывать все особенности
    сравнения символов французского языка.
*/

string pancakeFromUser = "crêpe";       // Означает слово "блин" по-французски
string pancakeFromDb = "cre\u0302pe";   // То же самое, но закодировано по-другому

// Вариант 1 (предпочтительный): использовать вариант сравнения "CurrentCulture"
Console.WriteLine(pancakeFromUser.Equals(pancakeFromDb, StringComparison.CurrentCulture));  // True

// Вариант 2: нормализовать строки перед сравнением
// Подробнее про нормализацию:
// https://learn.microsoft.com/en-us/dotnet/api/system.string.normalize?view=net-8.0
// https://learn.microsoft.com/en-us/windows/win32/intl/using-unicode-normalization-to-represent-strings
Console.WriteLine(pancakeFromUser.Normalize() == pancakeFromDb.Normalize());                // True


Console.WriteLine("\n-----------------Culture specific comparison potential bugs-----------------");

/******************************************************************************************************************************
    3. Ваша программа проверяет, является ли файл иконкой или нет, и выполняет какую-то логику на основе этого. Вы просто
       проверяете, имеет ли файл расширение ".ico". Вы выполняете данную проверку без учёта регистра. Ваше приложение
       мультиязычное. Всё было хорошо до тех пор, пока вы не развернули его в Турции. Для некоторых файлов расширение вдруг
       начало определяться неверно. В чём может быть причина и как это можно исправить?
******************************************************************************************************************************/

/*
    Всё дело в том, что метод "EndsWith" по умолчанию при сравнении строк использует текущую культуру, то есть, "CurrentCulture".
    Как мы уже помним из урока, в турецком языке маленькой букве "i" с точкой соответствует большая "İ" тоже с точкой.
    Это поведение отличается от большиства других языков, где маленькой "i" с точкой соответствует большая "I" без точки.
    Ну и так как расширение у нас записывается обычными английскими буквами, то в нём большая "I" не имеет точки, и при сравнении
    без учёта регистра в турецком языке она считается не равной маленькой "i" с точкой.
    Метод "IsIcon" в данном случае написан неверно. Так как расширения записыватся стандартными англйиским буквами, нам тут не
    нужно учитывать специфические особенности конкретных языков. Мы должны использовать "Ordinal" сравнение, которое не будет
    зависеть от культуры.
*/

string fileName = "Arrow.ICO";

Console.WriteLine(IsIcon(fileName)); // True - верно, так как файл имеет расширение ".ico".

// Меняем культуру на турецкую.
CultureInfo.CurrentCulture = new CultureInfo("tr-TR");

Console.WriteLine(IsIcon(fileName)); // После исправления метода "IsIcon" также "True".

static bool IsIcon(string fileName)
{
    return fileName.EndsWith(".ico", StringComparison.OrdinalIgnoreCase); // Просто меняем на "StringComparison.OrdinalIgnoreCase"
}

// Восстановление изначальной культуры, чтобы она не влияла на следующие задания.
CultureInfo.CurrentCulture = originalCulture;


/******************************************************************************************************************************
    4. В вашем приложении, когда пользователь печатает в текстовом поле, вам нужно автоматически приводить текст к верхнему
       регистру. Вы написали функцию "ToUpperCase" (см. код ниже), которая принимает в себя текст и возвращает его в верхнем
       регистре. Ваше приложение мультиязычное. Через какое-то время вы начинаете получать жалобы от пользователей некоторых
       стран, что приведение к верхнем регистру для некоторых символов работает неверно.
       В чём может быть причина и как это можно исправить?
******************************************************************************************************************************/

/*
    Тут ситуация обратная предыдущему заданию. В функции использована версия метода "ToUpperInvariant", которая применяет,
    так называемую, инвариантную культуру и не учитывает какие-то специфические правила конкретных языков. Например, будет
    возникать всё та же проблема с буквой "i" для турецкого языка. Она будет приводиться к верхнему регистру без учёта точки,
    то есть, всегда к версии "I" без точки, что для турецкой культуры неверно. Версия "ToUpperInvariant" подходит для случаев,
    когда вы хотите нормализовать регистр для какого-то последующего сравнения (см. первое задание). Но когда вам нужно выводить
    результат пользователю, должна использоваться именно версия "ToUpper", которая использует текущую культуру, а значит учитывает
    специфические особенности конкретных языков.
*/

string ToUpperCase(string text)
{
    return text.ToUpper();  // Просто меняем на "ToUpper"
}


Console.WriteLine("\n-----------------Types mismatching-----------------");

/*********************************************************************************************************
    5. У вас объявлены два символа. Вы пытаетесь их сравнить, но почему-то получаете ошибку компиляции.
       В чём причина? Предложите варианты исправления:
         5.1. Если вам разрешено изменять тип исходных переменных.
         5.2. Если вам не разрешено изменять тип исходных переменных.
*********************************************************************************************************/

/*
    Проблема в том, что символы объявлены как строки, так как заключены в двойные кавычки,
    а к строкам не применимы операторы больше-меньше.
*/

// 5.1. Если разрешено изменять тип, то можно просто сделать переменные типа "char", использовав одинарные, а не двойные кавычки.
{
    var symbol1 = 'x';
    var symbol2 = 'b';

    Console.WriteLine(symbol1 > symbol2);
}

// 5.2. Если не разрешено изменять тип, то необходимо применить метод "Compare" для сравнения строк. Из урока мы должны
//      помнить, что метод "Compare" возвращает число больше нуля, если первая строка больше второй. То есть, чтобы
//      повторить логику первоначального сравнения, нам нужно определить, будет ли результат больше нуля.
{
    var symbol1 = "x";
    var symbol2 = "b";

    // Так как мы сравниваем символы, скорей всего достатоно "Ordinal" сравнения.
    Console.WriteLine(string.CompareOrdinal(symbol1, symbol2) > 0);

    // Но, при необходимости, можно указать и культурно-зависимые варианты сравнения.
    Console.WriteLine(string.Compare(symbol1, symbol2, StringComparison.InvariantCulture) > 0);
    Console.WriteLine(string.Compare(symbol1, symbol2, StringComparison.CurrentCulture) > 0);

    // Экземплярный метод по умолчанию использует вариант сравнения "CurrentCulture" (не рекомендуется).
    Console.WriteLine(symbol1.CompareTo(symbol2) > 0);
}


Console.WriteLine("\n-----------------Culture specific comparison-----------------");

/************************************************************************************************************
    6. Вам необходимо сравнить две строки ниже на равенство без учёта регистра именно в испанской культуре.
       Но вы не хотите менять культуру на уровне приложения. Как вы можете это сделать?
       Испанская культура обозначается как "es-ES".
************************************************************************************************************/

string expectedText = "Ver Conexión";
string actualText = "ver conexión";

/*
    Метод "string.Compare" имеет перегрузку, которая умеет принимать конкретную культуру. Чтобы определить,
    равны ли две строки, необходимо сравнить результат с нулём. Помним, что метод "Compare" возвращает ноль
    только в случае, если строки равны. Это как раз то, что нам нужно.
*/

Console.WriteLine(string.Compare(actualText, expectedText, true, CultureInfo.GetCultureInfo("es-ES")) == 0);


Console.WriteLine("\n-----------------Sorting-----------------");

/*************************************************************************************************************************************
    7. У вас есть массив строк. Вам необходимо произвести его сортировку.
         7.1. С учётом текущей культуры.
         7.2. Вообще без учёта каких-либо лингвистических особенностей символов, то есть, по их кодам в таблице Unicode.
         7.3. С учётом лингвистических особенностей символов, но без учёта конкретной культуры. То есть, результат
              сортировки не должен меняться при запуске с различными культурами.

       Во всех вариантах регистр должен учитываться.
       Выведите в консоль результаты каждой сортировки. Для вывода используйте метод "string.Join" из урока с разделителем ", ".
       Есть ли различия? Если консоль не может отобразить некоторые символы корректно, проверьте результаты в отладчике.
       Попробуйте теперь сменить культуру на шведскую "sv-SE". Появятся ли какие-то ещё различия?
       Смените культуру обратно на исходную.
*************************************************************************************************************************************/

// Изменение текущей культуры на шведскую (раскомментируйте для сравнения).
// CultureInfo.CurrentCulture = new CultureInfo("sv-SE");

string[] words = [ "Cat", "dog", "apple", "Æble", "wink", "able", "Table", "ångström"];

// 7.1. В принципе, можно вообще явно не передавать компаратор, так как по умолчанию используется как раз "CurrentCulture".
//      Но мы должны помнить из статьи про Best practices, что лучше не полагаться на поведение по умолчанию, и всегда
//      указывать вариант сравнения явно.
Array.Sort(words, StringComparer.CurrentCulture);  // То же самое, что и "Array.Sort(words)"
Console.WriteLine(string.Join(", ", words));

// 7.2.
Array.Sort(words, StringComparer.Ordinal);
Console.WriteLine(string.Join(", ", words));

// 7.3.
Array.Sort(words, StringComparer.InvariantCulture);
Console.WriteLine(string.Join(", ", words));

// Восстановление изначальной культуры.
CultureInfo.CurrentCulture = originalCulture;


Console.WriteLine("\n-----------------Culture specific formatting (money)-----------------");

/********************************************************************************************************************************
    8. У вас объявлена переменная, содержащая цену Bitcoin. Вам необходимо вывести в консоль строку
       "Bitcoin price is {price}" в различных форматах и культурах.
          8.1. В текущей культуре в формате с разделителями групп разрядов и четырьмя знаками после запятой.
               После самой цены также необходимо добавить знак доллара. Например, для русской культуры
               результат должен быть:                              "Bitcoin price is 71 423,4826 $"
          8.2. Аналогично пункту 8.1, но в культуре США:           "Bitcoin price is 71,423.4826 $"
          8.3. Аналогично пункту 8.1, но в культуре Германии:      "Bitcoin price is 71.423,4826 $"
          8.4. Аналогично пункту 8.1, но в инвариантной культуре:  "Bitcoin price is 71,423.4826 $"
          8.5. Примените стандартный для США денежный формат вывода (спецификатор "С"). Культура должна быть также США.
               То есть, результат должен быть: "Bitcoin price is $71,423.48"

       Ссылки на спецификаторы форматирования чисел:
         https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings#standard-format-specifiers
         https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings
*********************************************************************************************************************************/

CultureInfo usCulture = new("en-US");
CultureInfo deCulture = new("de-DE");

decimal bitcoinPrice = 71423.482564m;

Console.WriteLine($"Bitcoin price is {bitcoinPrice:N4} $");                                             // 8.1 (спецификатор "N4")
Console.WriteLine($"Bitcoin price is {bitcoinPrice.ToString("N4", usCulture)} $");                      // 8.2 (спецификатор "N4")
Console.WriteLine($"Bitcoin price is {bitcoinPrice.ToString("N4", deCulture)} $");                      // 8.3 (спецификатор "N4")
Console.WriteLine($"Bitcoin price is {bitcoinPrice.ToString("N4", CultureInfo.InvariantCulture)} $");   // 8.4 (спецификатор "N4")
Console.WriteLine($"Bitcoin price is {bitcoinPrice.ToString("C", usCulture)}");                         // 8.5 (спецификатор "С")


Console.WriteLine("\n-----------------Culture specific formatting (floating numbers)-----------------");

/******************************************************************************************************
    9. У вас объявлена переменная, которая отражает концентрацию CO2 в миллионных долях (ppm).
       Вам необходимо вывести в косноль строку "CO2 concentration is {concentration} ppm".
       Формат должен быть без разделителей групп разрядов с тремя знаками после запятой.
         9.1. В текущей культуре, например, для РФ это будет:  "CO2 concentration is 4123,450 ppm"
         9.2. В культуре США:                                  "CO2 concentration is 4123.450 ppm"
         9.3. В культуре Германии:                             "CO2 concentration is 4123,450 ppm"
         9.4. В инвариантной культуре:                         "CO2 concentration is 4123.450 ppm"
******************************************************************************************************/

double co2Concentration = 4123.45;

Console.WriteLine($"CO2 concentration is {co2Concentration:F3} ppm");                                             // 9.1 (спецификатор "F3")
Console.WriteLine($"CO2 concentration is {co2Concentration.ToString("F3", usCulture)} ppm");                      // 9.2 (спецификатор "F3")
Console.WriteLine($"CO2 concentration is {co2Concentration.ToString("F3", deCulture)} ppm");                      // 9.3 (спецификатор "F3")
Console.WriteLine($"CO2 concentration is {co2Concentration.ToString("F3", CultureInfo.InvariantCulture)} ppm");   // 9.4 (спецификатор "F3")


Console.WriteLine("\n-----------------Culture specific formatting (percent)-----------------");

/*******************************************************************************************************************************
    10. У вас объявлена переменная, которая отражает годовую доходность в долях единицы, то есть, например, 0.127
        означает 12.7%. Вам необходимо вывести в консоль строку "Annual profit is {profit} %". Но значение должно
        отображаться именно в процентах с одним знаком после запятой.
          10.1. В текущей культуре, например, для РФ это будет:  "Annual profit is 12,7 %"
          10.2. В культуре США:                                  "Annual profit is 12.7%"
          10.3. В культуре Германии:                             "Annual profit is 12.7 %"
          10.4. В инвариантной культуре:                         "Annual profit is 12.7 %"
********************************************************************************************************************************/

decimal annualProfit = 0.127m;

// Можно конечно сделать это вручную, умножив на 100, применив спецификатор "F1" и добавив знак "%", например:
Console.WriteLine($"Annual profit is {annualProfit * 100:F1} %");                                     // 10.1 (спецификатор "F1")

// Но существует и специальный спецификатор "P", который сам умножает значение на 100 и подставляет знак "%":
Console.WriteLine($"Annual profit is {annualProfit:P1}");                                             // 10.1 (спецификатор "P1")
Console.WriteLine($"Annual profit is {annualProfit.ToString("P1", usCulture)}");                      // 10.2 (спецификатор "P1")
Console.WriteLine($"Annual profit is {annualProfit.ToString("P1", deCulture)}");                      // 10.3 (спецификатор "P1")
Console.WriteLine($"Annual profit is {annualProfit.ToString("P1", CultureInfo.InvariantCulture)}");   // 10.4 (спецификатор "P1")


Console.WriteLine("\n-----------------Culture specific formatting (date and time)-----------------");

/**************************************************************************************************************************************
    11. Вам дана дата. Для каждого из форматов ниже выведите её в четырёх различных культурах: текущей, США, немецкой, инвариантной.
        Примеры приведены для культуры США. Для других культур вывод может отличаться.
          11.1. Только месяц и число:                         March 9
          11.2. Только время в формате часы:минуты:           7:42 PM
          11.3. Только год и месяц:                           March 2024
          11.4. Полностью дата и время (без секунд):          Saturday, March 9, 2024 7:42 PM
          11.5. Сокращённый день недели и число:              Sat, 9
          11.6. Только месяц:                                 March
          11.7. Дата в формате ISO 8601:                      2024-03-09T19:42:57.4320000
                  Зависит ли вывод даты в данном формате от культуры? Как вы думаете, почему?

        Ссылки на спецификаторы форматирования дат:
          https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings
          https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
**************************************************************************************************************************************/

DateTime date = new(2024, 3, 9, 19, 42, 57, 432);

// 11.1.
Console.WriteLine(date.ToString("M"));
Console.WriteLine(date.ToString("M", usCulture));
Console.WriteLine(date.ToString("M", deCulture));
Console.WriteLine(date.ToString("M", CultureInfo.InvariantCulture));

Console.WriteLine();

// 11.2.
Console.WriteLine(date.ToString("t"));
Console.WriteLine(date.ToString("t", usCulture));
Console.WriteLine(date.ToString("t", deCulture));
Console.WriteLine(date.ToString("t", CultureInfo.InvariantCulture));

Console.WriteLine();

// 11.3.
Console.WriteLine(date.ToString("Y"));
Console.WriteLine(date.ToString("Y", usCulture));
Console.WriteLine(date.ToString("Y", deCulture));
Console.WriteLine(date.ToString("Y", CultureInfo.InvariantCulture));

Console.WriteLine();

// 11.4.
Console.WriteLine(date.ToString("f"));
Console.WriteLine(date.ToString("f", usCulture));
Console.WriteLine(date.ToString("f", deCulture));
Console.WriteLine(date.ToString("f", CultureInfo.InvariantCulture));

Console.WriteLine();

// 11.5.
Console.WriteLine(date.ToString("ddd, d"));
Console.WriteLine(date.ToString("ddd, d", usCulture));
Console.WriteLine(date.ToString("ddd, d", deCulture));
Console.WriteLine(date.ToString("ddd, d", CultureInfo.InvariantCulture));

Console.WriteLine();

// 11.6.
Console.WriteLine(date.ToString("MMMM"));
Console.WriteLine(date.ToString("MMMM", usCulture));
Console.WriteLine(date.ToString("MMMM", deCulture));
Console.WriteLine(date.ToString("MMMM", CultureInfo.InvariantCulture));

Console.WriteLine();

// 11.7.
/*
    Для вывода даты в формате ISO 8601 служит спецификатор "O" или "o". Данный формат соответствует интернациональному стандарту,
    поэтому не зависит от культуры. При выводе или парсинге всегда используется инвариантная культура и Григорианский календарь.
    https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#the-round-trip-o-o-format-specifier
*/
Console.WriteLine(date.ToString("O"));
Console.WriteLine(date.ToString("O", usCulture));
Console.WriteLine(date.ToString("O", deCulture));
Console.WriteLine(date.ToString("O", CultureInfo.InvariantCulture));


Console.WriteLine("\n-----------------Numbers input-----------------");

/***************************************************************************************************************************************
    12. В своём приложении вам необходимо считывать как целые, так и дробные числа от пользователей. Вы хотите использовать точный
        формат ввода, чтобы он не зависел от региональных параметров пользователя. В качестве разделителя групп разрядов должна
        использоваться "," или он должен отсутствовать, а разделителем целой и дробной части должна выступать ".".
        Какой самый простой способ это сделать?
        Напишите ниже код, который считывает число с консоли в описанном выше формате и преобразует его в тип "double".
        Выведите считанное число обратно в консоль.
        Протестируйте своё решение как на целых, так и на дробных числах. Как с разделителем групп разрядов, так и без.
***************************************************************************************************************************************/

/*
    Для решения данной задачи проще всего использовать инвариантную культуру, так как она не зависит от текущих региональных параметров
    пользователя, а также как раз использует "," в качестве разделителя групп разрядов и "." в качестве разделителя целой и дробной части.
*/

Console.Write("Enter a number: ");
string numberStr = Console.ReadLine();
double number = double.Parse(numberStr, CultureInfo.InvariantCulture);
Console.WriteLine(number);

/*
    Если вы внимательно тестировали с разделителями групп разрядов, то должны были уже понять, почему, когда мы на уроке считывали число 5,7
    в инвариантной культуре, мы получали в итоге число 57. Просто инвариантная культура воспринимает "," в качестве разделителя групп
    разрядов. Данный разделитель служит только для удобства восприятия больших чисел и никак не влияет на значение самого числа, поэтому
    5,7 и превращалось в 57.
*/


Console.WriteLine("\n-----------------Dates input-----------------");

/***************************************************************************************************************************************
    13. Считайте с консоли дату 2024-03-09 19:42:57 в различных культурах. Определите верный формат ввода для каждой культуры:
          13.1. Текущей.
          13.2. Культуры США.
          13.3. Инвариантной.
***************************************************************************************************************************************/

// Форматы ввода можно определить по форматам вывода

// 13.1. Мой текущий регион - это Россия, поэтому корректный формат даты и времени "09.03.2024 19:42:57"
{
    Console.Write("Enter a date: ");
    string dateStr = Console.ReadLine();
    DateTime parsedDate = DateTime.Parse(dateStr);
    Console.WriteLine(parsedDate);
}

// 13.2. Для США: "3/9/2024 7:42:57 PM"
{
    Console.Write("Enter a date: ");
    string dateStr = Console.ReadLine();
    DateTime parsedDate = DateTime.Parse(dateStr, usCulture);
    Console.WriteLine(parsedDate);
}

// 13.2. Для инвариантной культуры: 03/09/2024 19:42:57
{
    Console.Write("Enter a date: ");
    string dateStr = Console.ReadLine();
    DateTime parsedDate = DateTime.Parse(dateStr, CultureInfo.InvariantCulture);
    Console.WriteLine(parsedDate);
}

/*
    Фактически при считывании дат и времени парсер пытается сделать лучшее, на что он способен, и иногда можно ввести дату и в других форматах.
    Например, вот такой формат "2024-03-09 19:42:57" тоже будет работать в любой из предыдущих культур.
    Но на это лучше не полагаться, так как возможно попасть на трудноуловимые баги. Самый популярный из них - это перепутывание местами
    числа и месяца, так как в разных культурах они указываются на разных местах. Сравните, например, дату в формате США и РФ.
*/

/*
    Также есть возможность считывания даты в точно заданном формате. Для этого предназначен метод "ParseExact".
    Вы можете поэкспериментировать с ним самостоятельно.
*/


Console.WriteLine("\n-----------------Descending sorting-----------------");

/***************************************************************************************************************************************
    14*. Возможно вы заметили, что все встроенные компараторы сортируют строки по возрастанию. Но что если мы хотим отсортировать
         по убыванию? Первый вариант - это написать свой компаратор. Так как мы ещё не разбирали написание компараторов подробно,
         то его структура уже написана. Вам осталось только верно реализовать метод "Compare". В коде ниже реализована заглушка,
         которая всегда возвращает 0, а значит все строки будут считаться равными, и сортировки, как таковой, происходить не будет.
         Реализуйте верно метод "Compare", чтобы  строки на выходе были отсортированы по убыванию.

         Подумайте, можно ли добиться сортировки строк по убыванию, не реализуя свой собственный компаратор, а пользуясь только
         стандартными компараторами и методами класса "Array"?
***************************************************************************************************************************************/

{
    string[] stringArray = ["dog", "zero", "cat", "year"];
    Array.Sort(stringArray, new CurrentCultureDescendingComparer());
    Console.WriteLine(string.Join(", ", stringArray));  // zero, year, dog, cat 
}

/*
    Чтобы добиться сортировки по убыванию без написания собственного компаратора, можно сначала отсортировать массив по возрастанию,
    а потом просто перевернуть его элементы в обратном порядке, используя метод "Reverse" класса "Array".
    Но этот вариант менее оптимальный с точки зрения производительности, так как приходится делать дополнительный проход по массиву.
*/
{
    string[] stringArray = ["dog", "zero", "cat", "year"];
    Array.Sort(stringArray, StringComparer.CurrentCulture);
    Array.Reverse(stringArray);
    Console.WriteLine(string.Join(", ", stringArray));  // zero, year, dog, cat 
}

class CurrentCultureDescendingComparer : IComparer<string>
{
    public int Compare(string str1, string str2)
    {
        /*
            Из логики работы встроенных компараторов мы помним, что метод "Compare" возвращает число меньше нуля, если первая строка меньше второй,
            число больше нуля, если первая строка больше второй, и ноль, если строки равны. В таком случае строки будут отсортированы по возрастанию.
            Если мы перевернём данную логику, то строки как раз начнут сортироваться по убыванию. То есть, мы просто можем использовать встроенный
            компаратор, но поменять строки местами.
        */
        return string.Compare(str2, str1, StringComparison.CurrentCulture);  
    }
}
