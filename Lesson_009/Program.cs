/*****************************************************************************
    1. Какой фактический тип имеют данные неявно типизированные переменные?
*****************************************************************************/

var tempareture = 20.5f;             // float (из-за суффикса "f")
var length = 758934u;                // uint (из-за суффикса "u")
var balance = 1_425_580.54M;         // decimal (из-за суффикса "M")
var speed = 120;                     // int (поведение C# по умолчанию для целых чисел)
var bitFlags = 0b_1010_0001;         // int (это число 161, представленное в двоичной системе счисления, а значит C# назначает тип int согласно поведению по умолчанию)
var fileSizeInBytes = 74238075234;   // long (литерал не вмещается в тип int, поэтому C# по умолчанию назначает тип long)
var roomsCount = (short)3;           // short (явное приведение литерала к типу short)
var massOfTheSun = 1.989e30;         // double (поведение C# по умолчанию для литералов в научной нотации)
var distance = 758934LU;             // ulong (из-за суффикса "LU")
var memoryAddress = 0xF0423AC5F;     // long (Это число 64 493 956 191, представленное в 16-ричной системе счисления. Так как оно не "влезает" в тип int, то C# назначает тип long.)
var interestRate = 0.035;            // double (поведение C# по умолчанию для литералов с десятичной точкой)
var electronCharge = -1.602e-19;     // double (поведение C# по умолчанию для литералов в научной нотации)


/*************************************
    2. Исправьте ошибки компиляции.
*************************************/

// 1. Если мы хотим, чтобы тип был именно "float", то нужно добавить суффикс "f" или "F".
{
    float rate = 12.5F;
}

// 2. Просто исправить тип на "double"
{
    double rate = 12.5;
}


// Забыли добавить суффикс "m" или "M" для типа "decimal".
decimal cash = 525.3m;


// Суффикс "u" делает литерал типом "uint". Нельзя присвоить тип "uint" типу "byte" без явного приведения.
// 1. Просто убрать суффикс "u".
{
    byte grade = 5;
}

// 2. Сменить тип на "uint".
{
    uint grade = 5u;
}

// 3. Использовать ключевое слово "var" (тип переменной всё также будет "uint").
{
    var grade = 5u;
}


// По умолчанию C# интерпретируют литералы в научной нотации как "double".
// 1. Если нужен именно тип "long", то явно привести литерал к типу "long".
{
    long distanceToAlphaCentauri = (long)4.37e16;
}

// 2. Сменить тип на "double".
{
    double distanceToAlphaCentauri = 4.37e16;
}

// 3. Использовать ключевое слово "var" (тип переменной всё также будет "double").
{
    var distanceToAlphaCentauri = 4.37e16;
}


// Попытка присвоить целочисленному типу дробное число. По умолчанию C# интерпретирует цисла с десятичной точкой как "double".
// Без явного приведения нельзя присвоить тип "double" типу "int".

// 1. Если не нужно хранить дробную часть в данной переменной, то просто убрать десятичную часть.
{
    int percentage = 80;
}

// 2. Если же дробная часть всё-таки нужна, то сменить тип на "double" или использовать ключевое слова "var", что будет равносильно "double".
{
    double percentage = 80.0;
}


Console.WriteLine("-----------------Average speed-----------------");

/*********************************************************************************************************
    3. Вы вычисляете среднюю скорость автомобиля. Вам дано расстояние в км и время в часах.
       Но почему-то ваш результат обрезается до целого числа. В чём проблема? Как это можно исправить?
*********************************************************************************************************/

// Оба операнда целочисленные. Чтобы получить дробное число, хотя бы один из операндов должен иметь тип с плавающей точкой.

// 1. Просто привести любой операнд, например, к типу "double" при вычислении скорости.
{
    int distanceToCityInKm = 230;
    int timeInHours = 4;
    var averageSpeed = distanceToCityInKm / (double)timeInHours;
    Console.WriteLine($"Средняя скорость: {averageSpeed} км/ч");
}

// 2. Странно, что переменная "timeInHours" целочисленная. Более подходящий для неё тип "double", так как пройдённое время в часах
//    вполне может быть не целым, например, 3.5ч. Возможно лучше объявить переменную "timeInHours" сразу как "double".
{
    int distanceToCityInKm = 230;
    double timeInHours = 4;
    var averageSpeed = distanceToCityInKm / timeInHours;
    Console.WriteLine($"Средняя скорость: {averageSpeed} км/ч");
}


Console.WriteLine("\n-----------------Remainder operator-----------------");

/*********************************************************************************************************************************
    4. Вам дано целое число, и вам необходимо определить, кратно ли оно 3-м. Какую арифметическую операцию вы бы использовали?
*********************************************************************************************************************************/

// Число кратно какому-либо другому числу, если оно делится на него без остатка.
// Лучше всего для этого подойдёт оператор "Остаток от деления". Если остаток при делении на 3 будет равен 0, то значит число кратно 3-м.

// 1. С помещением остатка в отдельную переменную
{
    int num = 4238445;
    // Вычисляем остаток от деления на 3.
    int remainder = num % 3;
    // Выводим в консоль результат сравнения остатка с нулём.
    // Оператор "==" возвращает true, если операнды равны, и "false" в противном случае.
    Console.WriteLine(remainder == 0);
}

// 2. Без использования отдельной переменной
{
    int num = 4238445;
    // Сразу вычисляем остаток и выводим результат сравнения с нулём в консоль.
    Console.WriteLine(num % 3 == 0);
}


Console.WriteLine("\n-----------------Increment/Decrement-----------------");

/*******************************************************************************************************
    5. Объявите переменную "x", равную 25. Декрементируйте её 3 раза, и инкрементируйте два раза.
       Используйте разные формы инкремента и декремента. Выведите в консоль получившийся результат.
*******************************************************************************************************/

int x = 25;
x--;
--x;
--x;

x++;
++x;

Console.WriteLine(x);


Console.WriteLine("\n-----------------Increment unexpected result-----------------");

/*********************************************************************************************************
    6. Я ожидаю в консоли 9, но почему-то получаю 8. Почему? Предложите несколько вариантов исправления.
*********************************************************************************************************/

// Используется постфиксная форма инкремента. При ней значение сначала возвращается, а только потом инкрементируется.
// То есть, переменной "z" присваивается ещё неикрементированное значение, а значит 8.

// 1. Использовать префиксную форму инкремента.
{
    int y = 8;
    int z = ++y;
    Console.WriteLine(z);
}

// 2. Инкрементировать переменную на отдельной строке.
{
    int y = 8;
    y++;
    int z = y;
    Console.WriteLine(z);
}

// 3. Не использовать инкремент, а просто добавить единицу.
//    Правда в этом случае изначальная логика программы чуть изменится, так как,
//    в отличие от условия и двух предыдущих вариантов, сама переменная "y" останется равной 8.
{
    int y = 8;
    int z = y + 1;
    Console.WriteLine(z);
}


Console.WriteLine("\n-----------------Fix expressions-----------------");

/*******************************************************************
    7. Исправьте выражения, чтобы получился ожидаемый результат.
*******************************************************************/

// Ожидается 30, а выводится 20
Console.WriteLine((10 + 5) * 2);    // Изменяем приоритет операций, оборачивая выражение 10 + 5 в скобки

// Ожидается 10, а выводится 58
Console.WriteLine(100 / (2 + 8));   // Изменяем приоритет операций, оборачивая выражение 2 + 8 в скобки

// Ожидается 100, а выводится 1
Console.WriteLine(50 / 5 * 10);     // Изменяем приоритет операций, убирая скобки из выражения 5 * 10

// Ожидается 6, а выводится 4
Console.WriteLine(30 % (4 * 2));    // Изменяем приоритет операций, оборачивая выражение 4 * 2 в скобки

// Ожидается 11, а выводится 10
{
    int k = 5;
    Console.WriteLine(k++ + 10 / 2);
}

// Тут все дело в постфиксной форме инкремента. Даже не смотря на то, что инкремент выполняется с наивысшим приоритетом,
// он выполняется согласно правилам постфиксной формы, а значит сначала возвращается значение "k", а только потом "k" инкрементируется.
// Исходя из этого, выражение в итоге превратится вот в такое: 5 + 10 / 2, ну а оно равно 10.

// 1. Использовать префиксную форму инкремента
{
    int k = 5;
    Console.WriteLine(++k + 10 / 2);
}

// 2. Инкрементировать переменную k на отдельной строке
{
    int k = 5;
    k++;
    Console.WriteLine(k + 10 / 2);
}


Console.WriteLine("\n-----------------Simplify assignement-----------------");

/**********************************
    8. Упростите присваивание.
**********************************/

int a = 15;
double b = -7.8;
float c = 15.6f;
long d = -43289L;

a *= 83;
b -= 234.523;
c += 56.32f;
d %= 45;


/*********************************************************************************************************************
    9. Чему будет равна каждая из переменных после последнего присваивания?
       Несмотря на то что последнее присваивание это полностью валидный C# код, писать так на практике не стоит,
       так как это очень запутывает разработчиков. Упростите данное присваивание.
*********************************************************************************************************************/

{
    int e = 16;
    int f = 25;
    int g = e += f -= 5;

    Console.WriteLine($"e = {e}");   // 36
    Console.WriteLine($"f = {f}");   // 20
    Console.WriteLine($"g = {g}");   // 36
}

// Присваивание выполняется справа налево, то есть, сначала выполняется выражение "f -= 5",
// затем "e += f", а затем уже "int g = e". Несмотря на то что все присваивания происходят в одной строке,
// это очень запутанный код, который трудно сходу понять. Лучше сделать каждое присваивание на
// отдельной строке. Так код будет намного читабельнее.

{
    int e = 16;
    int f = 25;

    f -= 5;
    e += f;
    int g = e;

    Console.WriteLine($"e = {e}");   // 36
    Console.WriteLine($"f = {f}");   // 20
    Console.WriteLine($"g = {g}");   // 36
}


Console.WriteLine("\n-----------------IEEE 754 floating point numbers innacuracy-----------------");

/************************************************************************************************************
    10. Вы вычисляете длину окружности радиусом R, а затем сравниваете её с референсным значением.
        Если посчитать длину на калькуляторе, то видно, что она в точности совпадает с эталоном.
        Но тем не менее в консоли выводится, что они не равны.
        В чём причина?
        Как можно исправить данную ситуацию, если погрешность, с которой вы готовы мириться, равна 0.00001?
************************************************************************************************************/

// Все дело в неточности представления чисел с плавающей точкой в памяти компьютера.

double radiusInMeters = 1.6;
double circleLength = 2 * 3.14 * radiusInMeters;
double referenceLength = 10.048;
// Вместо точного равенства, просто проверяем, что абсолютная разница между нашими числами меньше нашей приемлемой погрешности
bool areEqual = Math.Abs(circleLength - referenceLength) < 0.00001;

Console.WriteLine($"Matches the reference value: {(areEqual ? "Yes" : "No")}");
