/******************************************************************
    1. Некоторые строки не компилируются. Почему? Исправьте код.
******************************************************************/

int i = 53;

long l = i;              // Расширяющее преобразование. Безопасно, поэтому происходит неявно.
float f = i;             // Расширяющее преобразование. Безопасно, поэтому происходит неявно (см. нюанс ниже).
byte b = (byte)i;        // Сужающее преобразование. Небезопасно, необходимо явное приведение типа.
i = b;                   // Расширяющее преобразование. Безопасно, поэтому происходит неявно.
double d = f;            // Расширяющее преобразование. Безопасно, поэтому происходит неявно.
l = (long)f;             // Сужающее преобразование. Приведение типов с плавающей точкой к целымм типам всегда небезопасно, так как приводит к потере дробной части. Необходимо явное преобразование типа.
ushort us = b;           // Расширяющее преобразование. Безопасно, поэтому происходит неявно.
f = (float)d;            // Сужающее преобразование. Небезопасно, необходимо явное приведение типа.
decimal c = (decimal)d;  // Типы с плавающей точкой стандарта IEEE 754 всегда нужно приводить к типу "decimal" явно.
c = i;                   // Расширяющее преобразование. Безопасно, поэтому происходит неявно.
i = (int)l;              // Сужающее преобразование. Небезопасно, необходимо явное приведение типа.
i = us;                  // Расширяющее преобразование. Безопасно, поэтому происходит неявно.
f = l;                   // Расширяющее преобразование. Безопасно, поэтому происходит неявно (см. нюанс ниже).

/*
    Несмотря на то что второе и последнее преобразования считаются расширяющими и происходят неявно, здесь все-таки возможна потеря точности.
    Потеря точности не будет такой глобальной, как, например, происходит при переполнении, когда, присваивая число 300 переменной типа "byte",
    мы в итоге получали число 44, которое очень далеко от оригинала. Но тем не менее для очень больших чисел (как положительных, так и отрицательных)
    число может быть не совсем тем, что было изначально. На самом деле это довольно очевидно, так как тип "float" имеет размер 32 бита, а тип "long" 64 бита.
    Тип "float" никак не может вместить весь диапазон чисел типа "long". Тем не менее разработчики языка посчитали, что такое преобрзование можно делать неявно.
    Слишком большие или слишком маленькие числа в принципе не могут быть представлены точно типами с плавающей точкой стандарта IEEE 754. Например, тип "float",
    имеет точность 24 бита, а значит точно могут быть представлены целые числа в диапазоне от -2^24 до 2^24, то есть, от −16 777 216 до 16 777 216.
    Если числа выходят за данный диапазон, то может теряться точность, и давайте даже на это посмотрим.
*/

Console.WriteLine("-----------------IEEE 754 floating point numbers precision issues-----------------");

Console.WriteLine(16777216f);  // Представлено точно. Видим 16777216 в консоли.
Console.WriteLine(16777217f);  // Округлено в меньшую сторону. Все ещё видим 16777216 в консоли.
Console.WriteLine(16777218f);  // Представлено точно. Видим 16777218 в консоли.
Console.WriteLine(16777219f);  // Округлено в большую сторону. Видим 16777220 в консоли.
Console.WriteLine(16777220f);  // Представлено точно. Видим 16777220 в консоли.

/*
    Соответственно, чем больше число, тем больше будет и погрешность округления. Как видим, диапазон чисел, которые могут быть представлены
    точно типом "float", даже меньше диапазона типа "int", а значит даже при присваивании переменной типа "int" переменной типа "float",
    возможна потеря точности. И это как раз тот нюанс, который я упоминал на уроке.
*/


/****************************************************************************
    2. Строки не компилируются. Почему? Исправьте код.
       Для некоторых строк предложите больше одного варианта исправления.
****************************************************************************/

short height = 342;
// Результат "height - 100" будет типа "int", а тип "int" нельзя присвоить типу "short" без явного преобразования
short width = (short)(height - 100);
// Результат "height / 2" будет типа "int", а тип "int" нельзя присвоить типу "short" без явного преобразования
height = (short)(height / 2);

// Второй вариант - использовать составное присваивание, тогда явное преобразование типа не нужно
height /= 2;


// Результат "f1 * f2" будет типа "double", так как переменная "f2" имеет тип "double". А когда хотя бы один из операндов имеет тип "double",
// то второй также "подтягивается" до типа "double", и результат соответственно тоже будет иметь тип "double".

// Вариант 1 (наиболее предпочтительный): изменить тип результата на "double"
{
    var f1 = 1.5f;
    var f2 = 2.5;
    double product = f1 * f2;
}

// Вариант 2: если приемлемо, изменить тип переменной "f2" на "float"
{
    var f1 = 1.5f;
    var f2 = 2.5f;
    float product = f1 * f2;
}

// Вариант 3: если приемлемо, привести переменную "f2" к типу "float" в самом выражении
{
    var f1 = 1.5f;
    var f2 = 2.5;
    float product = f1 * (float)f2;
}


// Результат "x + y" будет типа "long", так как переменная "y" имеет тип "long". А когда хотя бы один из операндов имеет тип "long",
// то второй также "подтягивается" до типа "long", и результат соответственно тоже будет иметь тип "long".

// Вариант 1 (наиболее предпочтительный): изменить тип результата на "long"
{
    int x = 1000;
    long y = 2000;
    long sum = x + y;
}

// Вариант 2: если приемлемо, изменить тип переменной "y" на "int"
{
    int x = 1000;
    int y = 2000;
    int sum = x + y;
}

// Вариант 3: если приемлемо, привести переменную "y" к типу "int" в самом выражении
{
    int x = 1000;
    long y = 2000;
    int sum = x + (int)y;
}


// При выполнении арифметиских операций между типами с плавающей точкой стандарта IEEE 754 и типом "decimal" всегда необходимо явное преобразование.

// Вариант 1: явно привести литерал к типу "decimal"
{
    decimal cash = 5000m;
    decimal total = cash + (decimal)50.7;
}

// Вариант 2: использовать суффикс
{
    decimal cash = 5000m;
    decimal total = cash + 50.7m;
}


// Результат "num1 - num2" будет типа "double", так как переменная "num2" имеет тип "double". А когда один из операндов имеет тип "double",
// а второй целочисленный, то целочисленный операнд также "подтягивается" до типа "double", и результат соответственно тоже будет иметь тип "double".

// Вариант 1 (наиболее предпочтительный): изменить тип результата на "double"
{
    int num1 = 80342;
    double num2 = 6543;
    double diff = num1 - num2;
}

// Вариант 2: если нам нужен именно целочисленный результат, то привести либо переменную "num2", либо все выражение явно к типу "int".
// При этом нужно учитывать, что если переменная "num2" будет иметь дробную часть, то в результате мы её потеряем.
{
    int num1 = 80342;
    double num2 = 6543;
    int diff = (int)(num1 - num2);
}


/********************************************************
    3. Объясните, почему строки ниже не компилируются.
       Предложите варианты исправления.
********************************************************/


// Компилятор умеет выполнять арифметические операции над литералами и константами и сразу видит, что происходит переполнение.

const int constNum = 500;

// "128 * 2 = 256", что выходит за пределы диапазона типа "byte". Необходимо изменить тип переменной, например, на short или int.
short b3 = 128 * 2;

// "257 - constNum = -243", что выходит за пределы диапазона типа "uint". Необходимо изменить тип переменной, например, на int.
int ui3 = 257 - constNum;

// "short.MinValue" - это константа, объявленная внутри типа "short". Так как компилятор умеет производить арифметические операции
// с литералами и константами, он сразу предупреждает нас о переполнении. Необходимо изменить тип переменной, например, на int.
int s3 = short.MinValue - 1;


Console.WriteLine("\n-----------------Overflow-----------------");

/*************************************************************************************
    4. В строке ниже переменная "z" инкрементируется, а затем выводится в консоль.
       Но, вместо числа 128, мы видим -128. Объясните, почему так происходит.
       Объясните, почему в консоли мы видим именно число -128.
*************************************************************************************/

/*
    Диапазон типа "sbyte" равен -128..127. После инкрмента мы должны получить число 128, но мы видим, что оно выходит
    за границы диапазона типа "sbyte". То есть, происходит переполнение. Чтобы понять почему в итоге получилось именно
    число -128, нам нужно выяснить как эти числа представлены в памяти компьютера.
    Тип "sbyte" занимает в памяти 8 бит. Тип знаковый, то есть, один старший бит отводится под хранение знака числа.
    Если он равен 0, то число положительное, а если 1, то отрицательное. Остальные 7 бит отводятся под хранение самого числа.
    То есть, число 127 хранится в типе "sbyte" следующим образом "0111 1111": знаковый бит равен нулю, так как число положительное,
    а остальные 7 бит равны 1, что соответствует нашему числу 127. Далее мы инкрементируем наше число, то есть, добавляем к нему 1.
    Сложение происходит так же, как и в десятичной системе. Мы можем сделать это столбиком:

    01111111
   + 
    00000001
    --------
    10000000

    То есть, после инкремента мы получаем число 10000000. Как видим, старший бит сменился на 1, то есть, число стало отрицательным.
    Остальные биты равны 0. Казалось бы, мы должны получить число -0. И, если бы использовался, так называемый, прямой код (ссылка ниже),
    то так бы и было. Но числа в компьютере в настоящее время хранятся в, так называемом, дополнительном коде (ссылка ниже), про который
    я уже упоминал в одном из уроков. В нём отрицательное число из положительного можно получить путём инвертирования всех разрядов
    и добавления единицы. То есть, например, число 5 представляется как "0000 0101". Чтобы понять, как представляется число -5, делаем два действия:

        1. Инвертируем все разряды, получаем "1111 1010";
        2. Добавляем единицу, получаем "1111 1011".

    Это и будет представление числа -5 в двоичной системе в дополнительном коде.
   
    Поэтому, в дополнительном коде двоичная запись "1000 0000" соответствует именно числу -128, что мы и видим в консоли.

    Почему для представления чисел в настоящее время используется именно дополнительный код, вы можете почитать по ссылке или найти дополнительные материалы.

    Прямой код: https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D0%B9_%D0%BA%D0%BE%D0%B4
    Дополнительный код: https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4
*/

sbyte z = 127;
z++;
Console.WriteLine($"z = {z}");


/***********************************************************************************************
    5. Сделайте так, чтобы переполнения в коде ниже вызывали ошибку, а не происходили неявно.
***********************************************************************************************/

{
    int bigNum = 1_984_923_475;
    int overflow1 = checked(bigNum * 2);

    short overflow2 = short.MinValue;
    checked
    {
        overflow2--;
    }
}

// Или можно просто обернуть весь блок кода в выражение checked
checked
{
    int bigNum = 1_984_923_475;
    int overflow1 = bigNum * 2;

    short overflow2 = short.MinValue;
    overflow2--;
}


/***********************************************************************************************************************************
    6. Включите проверку переполнений глобально на уровне проекта.
       Проверьте корректность на предыдущем задании - уберите явную проверку переполнений и запустите проект.
       Если глобальная проверка включена корректно, то вы все также должны будете получать ошибку на первом переполнении overflow1.
       Отключите явно проверку для первого выражения c overflow1. Если все сделано корректно, то ошибка должна происходить
       только на последнем переполнении overflow2.
************************************************************************************************************************************/

// Для включения проверки переполнений глобально следуйте шагам из урока.

// Явное отключение проверки переполнения для переменной overflow1:
{
    int bigNum = 1_984_923_475;
    int overflow1 = unchecked(bigNum * 2);
}


/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   Для выполнения заданий ниже отключите глобальную проверку переполнений, а также уберите все явные
   проверки переполнений, иначе из-за ошибки программа просто прервется и не дойдёт до строк ниже.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

Console.WriteLine("\n-----------------Numeric types members investigation-----------------");

/***********************************************************************************************************************************************
    7. Исследование членов числовых типов
       7.1  Найдите и попробуйте метод в типе "int", который определяет, что число отрицательное.
       7.2  Найдите и попробуйте метод в типе "int", который определяет, что число является степенью двойки.
       7.3  Найдите и попробуйте метод в типе "int", который сравнивает два числа и возвращает меньшее из них.
       7.4  Найдите и попробуйте метод в типе "int", который гарантирует, что переданное значение находится в необходимом диапазоне.
            Если значение выходит за пределы, то возвращается минимальная, либо максимальная граница.
       7.5  Найдите и попробуйте метод в типе "double", который вычисляет квадратный корень числа.
       7.6  Найдите и попробуйте метод в типе "double", который вычисляет корень числа n-ой степени.
       7.7  Найдите и попробуйте метод в типе "double", который вычисляет степень числа.
       7.8  Найдите и попробуйте метод в типе "double", который вычисляет десятичный логарифм числа.
       7.9  Найдите и попробуйте метод в типе "double", который определяет, что число конечно (то есть, не является бесконечностью или NaN).
       7.10 Найдите и попробуйте метод в типе "decimal", который определяет, что число целое.
       7.11 Найдите и попробуйте метод в типе "decimal", который отсекает дробную часть.
       7.12 Найдите и попробуйте метод в типе "decimal", который округляет дробную часть.
       7.13 Найдите и попробуйте метод в типе "decimal", который округляет до ближайшего целого вверх.
       7.14 Найдите и попробуйте метод в типе "decimal", который округляет до ближайшего целого вниз.
************************************************************************************************************************************************/

// 7.1  Найдите и попробуйте метод в типе "int", который определяет, что число отрицательное.
Console.WriteLine("\n-----------------IsNegative-----------------");

Console.WriteLine(int.IsNegative(5));
Console.WriteLine(int.IsNegative(-5));

// 7.2  Найдите и попробуйте метод в типе "int", который определяет, что число является степенью двойки.
Console.WriteLine("\n-----------------IsPow2-----------------");

Console.WriteLine(int.IsPow2(128));
Console.WriteLine(int.IsPow2(255));

// 7.3  Найдите и попробуйте метод в типе "int", который сравнивает два числа и возвращает меньшее из них.
Console.WriteLine("\n-----------------Min-----------------");

Console.WriteLine(int.Min(5, -10));

// 7.4  Найдите и попробуйте метод в типе "int", который гарантирует, что переданное значение находится в необходимом диапазоне.
//      Если значение выходит за пределы, то возвращается минимальная, либо максимальная граница.
Console.WriteLine("\n-----------------Clamp-----------------");

Console.WriteLine(int.Clamp(5, 10, 15));
Console.WriteLine(int.Clamp(12, 10, 15));
Console.WriteLine(int.Clamp(20, 10, 15));

// 7.5  Найдите и попробуйте метод в типе "double", который вычисляет квадратный корень числа.
Console.WriteLine("\n-----------------Sqrt-----------------");

Console.WriteLine(double.Sqrt(16)); // Корень квадратный из 16
Console.WriteLine(double.Sqrt(5));  // Корень квадратный из 5

// 7.6  Найдите и попробуйте метод в типе "double", который вычисляет корень числа n-ой степени.
Console.WriteLine("\n-----------------RootN-----------------");

Console.WriteLine(double.RootN(16, 4));  // Корень 4-ой степени из 16
Console.WriteLine(double.RootN(729, 6)); // Корень 6-ой степени из 729

// 7.7  Найдите и попробуйте метод в типе "double", который вычисляет степень числа.
Console.WriteLine("\n-----------------Pow-----------------");

Console.WriteLine(double.Pow(2, 5));      // 2 в степени 5
Console.WriteLine(double.Pow(5.2, 0.5));  // 5.2 в степени 0.5

// 7.8  Найдите и попробуйте метод в типе "double", который вычисляет десятичный логарифм числа.
Console.WriteLine("\n-----------------Log10-----------------");

Console.WriteLine(double.Log10(100));
Console.WriteLine(double.Log10(5));

// 7.9  Найдите и попробуйте метод в типе "double", который определяет, что число конечно (то есть, не является бесконечностью или NaN).
Console.WriteLine("\n-----------------IsFinite-----------------");

Console.WriteLine(double.IsFinite(0.1));
Console.WriteLine(double.IsFinite(double.Pi));
Console.WriteLine(double.IsFinite(double.NegativeZero));
Console.WriteLine(double.IsFinite(double.PositiveInfinity));
Console.WriteLine(double.IsFinite(double.NegativeInfinity));
Console.WriteLine(double.IsFinite(double.NaN));
Console.WriteLine(double.IsFinite(0.0 / 0));
Console.WriteLine(double.IsFinite(5.0 / 0));
Console.WriteLine(double.IsFinite(-5.0 / 0));

// 7.10 Найдите и попробуйте метод в типе "decimal", который определяет, что число целое.
Console.WriteLine("\n-----------------IsInteger-----------------");

Console.WriteLine(decimal.IsInteger(5345));
Console.WriteLine(decimal.IsInteger(5345.53m));

// 7.11 Найдите и попробуйте метод в типе "decimal", который отсекает дробную часть.
Console.WriteLine("\n-----------------Truncate-----------------");

Console.WriteLine(decimal.Truncate(5345.53m));

// 7.12 Найдите и попробуйте метод в типе "decimal", который округляет дробную часть.
Console.WriteLine("\n-----------------Round-----------------");

Console.WriteLine(decimal.Round(5345.53m));

// 7.13 Найдите и попробуйте метод в типе "decimal", который округляет до ближайшего целого вверх.
Console.WriteLine("\n-----------------Ceiling-----------------");

Console.WriteLine(decimal.Ceiling(5345.2m));
Console.WriteLine(decimal.Ceiling(5345.8m));
Console.WriteLine(decimal.Ceiling(5345));

// 7.14 Найдите и попробуйте метод в типе "decimal", который округляет до ближайшего целого вниз.
Console.WriteLine("\n-----------------Floor-----------------");

Console.WriteLine(decimal.Floor(5345.2m));
Console.WriteLine(decimal.Floor(5345.8m));
Console.WriteLine(decimal.Floor(5345));


Console.WriteLine("\n-----------------The 'Parse' method-----------------");

/*******************************************************************************************************
    8. Я считываю с консоли два числа и пытаюсь сложить их между собой (см. код ниже). Но, почему-то,
       я получаю неверный ответ. Например, если я ввожу 5 и 6, я получаю в консоли 56 вместо 11.
       В чём причина? Исправьте код.
*******************************************************************************************************/

/*
    Всё дело в том, что метод "ReadLine" возвращает строку. При применении оператора "+" между двумя
    строками происходит их конкатенация, то есть, они просто "склеиваются" между собой, поэтому при
    сложении "5" + "6" и получается в ответе 56. Чтобы сложить именно числа, необходимо сначала привести
    считанные строки к числовому типу, например, "int" с помощью метода "int.Parse" или "Convert.ToInt32".
 */

Console.Write("Enter first number: ");
var firstNum = int.Parse(Console.ReadLine());

Console.Write("Enter second number: ");
var secondNum = Convert.ToInt32(Console.ReadLine());

Console.WriteLine(firstNum + secondNum);
