/*********************************************************************************************************************
    1. В заданиях ниже вам предоставлены какие-то данные, и вам нужно объявить и инициализировать переменную
       в соответствии с описанными условиями. Именуйте вашу переменную в соответствии с её смысловым значением.
*********************************************************************************************************************/

// 1.1. Определите, находится ли данный вам год в диапазоне от 1900 включительно до 2000 не включительно.
int year = 1927;

// Вариант 1:
{
    bool isYearBetween = year >= 1900 && year < 2000;
}

// Вариант 2:
{
    bool isYearBetween = year >= 1900 && year <= 1999;
}


// 1.2. Определите, имеет ли пользователь право управлять автомобилем. Пользователь имеет право управлять автомобилем,
//      если ему 18 или более лет, и он имеет водительское удостоверение.
int age = 19;
bool hasDrivingLicense = true;

bool canDrive = age >= 18 && hasDrivingLicense;


// 1.3. Определите, поступил ли абитуриент в ВУЗ. Абитуриент считается поступившим,
//      если его балл по ЕГЭ больше 80 или он занимал призовые места.
int egeScore = 83;
bool hadOlympiadPrizes = false;

bool isEnteredUniversity = egeScore > 80 || hadOlympiadPrizes;


// 1.4. Определите, находится ли число вне диапазона от 10 до 20 включительно.
int number = 20;

// Вариант 1 (предпочтительный, так как более читаемый):
{
    bool isNumberOutsideRange = number < 10 || number > 20;
}

// Вариант 2:
{
    bool isNumberOutsideRange = !(number >= 10 && number <= 20);
}


// 1.5. Определите, кратно ли число 3-м или 7-и.
number = 129772;

bool isDivisibleByThreeOrSeven = number % 3 == 0 || number % 7 == 0;


// 1.6. Определите, что данный вам день недели является будним днём, то есть, не субботой и не воскресеньем.
//      Дни недели нумеруются от 1 до 7, то есть:
//        Понедельник - 1
//        Вторник - 2
//        ...
//        Воскресенье - 7
int dayOfWeek = 5;

bool isWeekday = dayOfWeek != 6 && dayOfWeek != 7;


// 1.7. Определите, может ли пользователь участвовать в предстоящем событии. Пользователь может участвовать,
//      если его возраст больше или равен 18 и меньше или равен 65, он является членом клуба и не имеет никаких
//      задолженностей.
age = 25;
bool isClubMember = true;
bool hasNoDebts = true;

bool canParticipate = age >= 18 && age <= 65 && isClubMember && hasNoDebts;

// 1.8. Определите, имеет ли сотрудник право на повышение. Сотрудник имеет право на повышение, если он проработал
//      3 года и более, его коэффициент производительности более 85, и он не имеет дисциплинарных нарушений.
int yearsWorked = 6;
int performanceScore = 87;
bool hasDisciplinaryActions = false;

bool isEligibleForPromotion = yearsWorked >= 3 && performanceScore > 85 && !hasDisciplinaryActions;


// 1.9. Определите, имеет ли пользователь право на скидку в гимнастический зал. Пользователь имеет право на скидку,
//      если он студент или его возраст равен или больше 60, а также он имеет членскую карту зала. 
bool isStudent = false;
age = 65;
bool hasGymMembershipCard = true;

bool isEligibleForDiscount = (isStudent || age >= 60) && hasGymMembershipCard;


// 1.10. Определите, имеет ли пользователь доступ к ограниченной зоне. Чтобы иметь такой доступ пользователь
//      должен быть админом или обычным пользователем со специальными разрешениями. В любом случае пользователь
//      должен иметь включенной многофакторную аутентификацию или заходить с доверенного устройства.
bool isAdmin = false;
bool hasSpecialPermissions = true;
bool isMfaEnabled = false;
bool isTrustedDevice = true;

bool canAccessRestrictedArea = (isAdmin || hasSpecialPermissions) && (isMfaEnabled || isTrustedDevice);


// 1.11. Определите, имеет ли сотрудник право на специальную льготную программу. Сотрудник имеет право на льготную программу, если:
//        - сотрудник имеет полный рабочий день и проработал в компании 5 лет или более
//        - сотрудник имеет неполный рабочий день, но имеет превосходный рейтинг производительности
//        - подрядчик со стажем работы не менее 7 лет и не имеющий негативных отзывов
bool isFullTimeEmployee = true;
bool isPartTimeEmployee = false;
bool isContractor = false;
int yearsOfWork = 12;
bool hasExcellentPerformance = false;
bool hasNegativeFeedback = false;

bool isEligibleForBenefits =
    (isFullTimeEmployee && yearsOfWork >= 5)
    || (isPartTimeEmployee && hasExcellentPerformance)
    || (isContractor && yearsOfWork >= 7 && !hasNegativeFeedback);


// 1.12. Определите, имеет ли пользователь доступ к закрытому событию. Пользователь имеет такой доступ, если у него VIP-статус
//       или он имеет специальное приглашение, но не то и другое одновременно.

bool isVip = false;
bool hasSpecialInvitation = true;

// Вариант 1 с использованием XOR (предпочтительный, так как более читаемый):
{
    bool hasAccessToPrivateEvent = isVip ^ hasSpecialInvitation;
}

// Вариант 2 без использования XOR:
{
    bool hasAccessToPrivateEvent = (isVip && !hasSpecialInvitation) || (!isVip && hasSpecialInvitation);
}


Console.WriteLine("-------------------Short-circuit vs full operators----------------------");

/***********************************************************************************************************
    2. Вы производите тестирование функционала. У вас есть два метода Check1() и Check2(). Методы
       тестируют какую-то логику и возвращают результаты проверок. Если успешно, то "true", а если
       нет, то "false". Также методы внутри себя логгируют результаты проверок. Для того чтобы функционал
       считался корректным, обе проверки должны пройти одновременно, то есть, оба метода должны вернуть
       "true". Вы делаете это следующим образом (см. код ниже), но через какое-то время замечаете,
       что если первый метод вернул "false", то второй метод ничего не логгирует. Вы же бы хотели, чтобы
       оба метода всегда логгировали свои результаты, независимо от успешности или неуспешности проверок.
       В чём причина и как это можно исправить?
***********************************************************************************************************/

/*
    Проблема в использовании short-circuit версии оператора "И". Если первый операнд возвращает "false", то
    конечный результат уже не зависит от второго операнда и также будет равен "false". По этой причине второй операнд
    даже не вычисляется. Это желаемое поведение в подавляющем большинстве случаев, но данный случай специфичен.
    Здесь мы хотим, чтобы выполнялись всегда оба метода, независимо от результатов, которые они возвращают.
    Чтобы этого достичь, нам необходимо использовать полную версию оператора "И".
*/

bool isFunctionalityCorrect = Check1() & Check2();
Console.WriteLine($"Functionality is correct: {isFunctionalityCorrect}");

bool Check1()
{
    bool checkResult = false;                            // Какая-то логика проверки функционала (в нашем случае просто присваиваем "false").
    Console.WriteLine($"Check1 result: {checkResult}");  // Логгирование результатов проверки. В нашем случае просто логгируем результат в консоль.
    return checkResult;                                  // Возврат результатов проверки (false - при некорректной работе, true - при корректной).
}

bool Check2()
{
    bool checkResult = true;                             // Какая-то логика проверки функционала (в нашем случае просто присваиваем "true").
    Console.WriteLine($"Check2 result: {checkResult}");  // Логгирование результатов проверки. В нашем случае просто логгируем результат в консоль.
    return checkResult;                                  // Возврат результатов проверки (false - при некорректной работе, true - при корректной).
}


/***********************************************************************************************************
    3. Почему не существует оператора XOR, который использует короткую схему вычисления (short-circuit)?
***********************************************************************************************************/

/*
    Потому что нет случаев, когда, оценив только первый операнд, вы могли бы наверняка сказать, каков будет конечный результат.
    Если первый операнд равен "false", конечный результат будет зависеть от второго операнда. Если он тоже "false", то результат
    будет "false", а если "true", то результат будет "true". Та же самая ситуация и если первый операнд равен "true". Всё
    будет зависеть от значения второго операнда. Если он тоже "true", то результат будет "false", а если он равен "false", то
    результат будет "true".
*/


Console.WriteLine("\n-------------------Operators precedence----------------------");

/***************************************************************************************
    4. В выражениях ниже ожидается один результат, но в реальности получается другой.
       В чём причина? Исправьте код.
***************************************************************************************/

/*
    4.1. Вы пытаетесь ограничить доступ к определённому ресурсу. Доступ к нему должны иметь только админы
         или обычные пользователи, но имеющие специальные права. Также доступ должен быть ограничен, если
         данный ресурс находится на техническом обслуживании. Вы объявили переменную "isAccessAllowed",
         которой присвоили соответствующее выражение. Но почему-то ограничение доступа работает некорректно.
         Например, в случае ниже доступ должен быть ограничен, потому что система находится на техническом
         обслуживании, но переменная почему-то содержит "true".
         В чём причина и как это можно исправить?
*/

/*
    Дело в приоритете операций. Сначала выполняется логическое "И", а потом только логическое "ИЛИ", поэтому
    результат получается некорректный. Нам нужно сначала выполнить "ИЛИ", а потом "И", для этого оборачиваем
    соответствующее выражение в скобки.
*/

isAdmin = true;
bool hasSpecialAccess = false;
bool underMaintenance = true;

bool isAccessAllowed = (isAdmin || hasSpecialAccess) && !underMaintenance;
Console.WriteLine(isAccessAllowed);


/*
    4.2. Магазин предлагает скидку, если вы купили более 3-х товаров или потратили более 5 тысяч, но только если
         это не распродажа. Вы объявили переменную "isDiscountApplied", которой присвоили соответствующее выражение.
         Но почему-то скидка применяется не всегда некорректно. Например, в случае ниже скидка примениться не должна,
         так как идёт распродажа, но она почему-то применяется.
         В чём причина и как это можно исправить?
*/

/*
    Дело в приоритете операций. Сначала выполняется логическое "И", а потом только логическое "ИЛИ", поэтому
    результат получается некорректный. Нам нужно сначала выполнить "ИЛИ", а потом "И", для этого оборачиваем
    соответствующее выражение в скобки.
*/

int itemsPurchased = 2;
decimal amountSpent = 6000;
bool isSale = true;

bool isDiscountApplied = !isSale && (itemsPurchased > 3 || amountSpent > 5000);
Console.WriteLine(isDiscountApplied);


Console.WriteLine("-------------------Short-circuit vs full operators (2)----------------------");

/*
    4.3. Система должна отсылать уведомление в случае ошибки или в случае предупреждения, но только если его уровень
         критичности больше 5. Вы объявили переменную "shouldSendNotification", которой присвоили соответствующее выражение.
         Но почему-то уведомления отсылаются не всегда корректно. Например, в случае ниже уведомление должно отсылаться,
         так как произошла ошибка, но переменная почему-то имеет значение "false".
         В чём причина и как это можно исправить?
*/

bool isError = true;
bool isWarning = false;
int warningLevel = 0;

/*
    Дело в том, что используется полная, а не short-circuit версия оператора "ИЛИ". Полные версии имеют приоритет
    над short-circuit версиями, поэтому в данном выражении сначала выполняется "ИЛИ", а потом "И". Скорей всего тут
    просто банальная опечатка, так как нет никакого смысла использовать полную версию оператора. Просто нужно
    сменить полную версию оператора "ИЛИ" на оператор, работающий по короткой схеме вычисления, то есть, заменить "|" на "||"
 */

bool shouldSendNotification = isWarning && warningLevel > 5 || isError;
Console.WriteLine(shouldSendNotification);
